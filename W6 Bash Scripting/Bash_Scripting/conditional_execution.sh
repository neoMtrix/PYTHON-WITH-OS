# One of the main concepts of programming is being able to branch the execution according to a condition. In other words, making our program behave in different ways depending on one or more values. In Python, we use the if block and the condition is an expression that has to evaluate to true or false. In bash scripting, the condition used is based on the exit status of commands. Do you remember what we discussed earlier about the exit status of commands? We mentioned that we check the exit status for command using the dollar sign question mark. And we called out that in bash scripting an exit value of zero means success. This logic is used by the if operator in bash. To create a conditional expression, we're going to call a command and if the exit status of that command is zero, then the condition will be considered true. Say we wanted to verify that the /etc/hosts file contains an entry for 127.0.0.1, which it should. Knowing that grep will return it exit status of zero when it finds at least one match and different than zero if it doesn't find a match, we can use it to do this verification. Check out this script.
cat check_localhost.sh
# Let's look at the syntax of the if block. We start with the if keyword followed by the grep command that we'll use to check for success. At the end of the command, we have a semicolon followed by the word then. After that comes the body of the conditional, make sense? We're using indentation like in Python. This is a good style choice, and it makes the code more readable. But it's not mandatory in Bash. It's possible to write this in one line and sometimes we might do that when the amount of code is small enough. In general, though, it's nice to have commands in separate lines and use indentation to clearly show the body of the conditional. We also have an else block for when the command doesn't finish successfully. And finally, our conditional block finishes using the FI keyword. You can see how some things are the same as in Python. It uses the if and else keywords, it checks a condition and branches the execution according to the value of the condition. But other things are different. We need to write semicolon then before we can start the body and we need to end the block with FI. Paying attention to these similarities and differences will make it easier for you to get acquainted with new programming languages. Okay, let's run our script and see what it does, here we go.
./check_localhost.sh
# The first line in the output is the one generated by our grep command, because by default, grep prints the lines that match the expression that we give it. The second line in the output is the one that was generated by our script. So in this case, the grep command called by our script found a line in the file and exited with a value of zero. So our script said that everything was okay. If grep hadn't found that line, it would have exited with a value different than zero and we would've received a different message. There is plenty of other conditions that we might want to check in our scripts, if the file exists, if two strings are equal, if a number is less than another number, and so on. To help us with evaluating these conditions, there is a command called Test. Test is a command that evaluates the conditions received and exits with zero when they are true and with one when they're false. Let's check out an example, in this case, it's short enough that we can write everything in one line.
if test -n "$PATH"; then echo "Your path is not empty"; fi
# We're using the -n option for the test command, which checks if a string variable is empty or not. In this case, path is an empty, so we get the message. Using the test command like this is so common, there's another way of writing it, which looks more like other programming languages. It's something like this.
if [ -n "$PATH" ]; then echo "Your path is not empty"; fi
# In this case, the command we're calling is the opening square bracket. This is an alias to the test command, but to call it successfully, we also need to include a closing square bracket. When using this syntax, remember, that there needs to be a space before the closing bracket. There's plenty of other things that we can check with test, but we won't cover them in these videos. We'll include some of them in the upcoming cheat sheet and you can also see all of them by looking at the manual page for test. So by now you have a rough idea of what a Bash script looks like. You're doing really good and remember, you can always review the contents if something isn't clear. There's a lot of topics that we haven't covered yet like walking of loops or merging command line arguments. But before we jump into that, let's do a quick quiz.