#!/usr/bin/env python3

import subprocess

# For example, say you wanted to create some stats on which users are logging into a server throughout the day. You could do this with a script that calls the who command, which prints the users currently logged into a computer. The script could parse the output of the command, storing the list of logged-in users once per hour and at the end of the date to generate a daily report. To be able to process the output of commands, we'll set a parameter called capture output to true when calling the run function.

result = subprocess.run(["host", "8.8.8.8"], capture_output=True)
print(result.returncode)

print(result.stdout)
# We can also print and operate with the output generated by the command, which is stored in the std out attribute.
# output: "b" tells us that this string is not a proper string for Python. It's actually an array of bytes.

print(result.stdout.decode().split())
#  let's transform our array of bytes into a string and then split it into several pieces.

result = subprocess.run(["rm", "does_not_exist"], capture_output=True)
print(result.returncode)
# But what about standard error? If we use the capture output parameter and the command writes any output to standard error, it will be stored in the std or attribute of the completed process instance. Let's look at an example of this. We'll try executing the rm command, which we use for removing files passing a filename that doesn't exist.

print(result.stderr)
# see that in this case, the standard output was empty.
#  let's check the contents of the stdout and stderr attributes.

# For our next example, we'll call the host command, which can convert a host name to an IP address and vice versa. When calling it, we'll pass the capture output equals true parameter and store the result in a variable so that we can access it. Let's give it a try.
